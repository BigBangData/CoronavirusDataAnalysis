---
title: "Coronavirus Data Analysis"
author: "Marcelo Sanches"
date: "07/03/2022"
output: 
  html_document:
    keep_md: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
```


This is an old project from the beginning of the pandemic which I just reran with a few changes, including making a quick [Shiny app](https://bigbangdata.shinyapps.io/shinyapp/) for the bar plots.

---

__April 2020__

This is a simple exploration of the time series data compiled from various sources at the [COVID-19 Data Repository by the Center for Systems Science and Engineering (CSSE) at Johns Hopkins University](https://github.com/CSSEGISandData/COVID-19). 

The raw data can also be downloaded manually at [Novel Coronavirus 2019 Cases.](https://data.humdata.org/dataset/novel-coronavirus-2019-ncov-cases) This [GitHub repository](https://github.com/BigBangData/CoronavirusDataAnalysis) hosts all files and code.


This project is not intended to be a serious data analysis, which would require more data and study. This is a personal project to explore automated plotting of the daily JHU datasets. **The plots produced here do not reflect reality and should not be taken as a model for how COVID-19 spreads through populations.** For example, they do not take into consideration the meaning of confirmed cases - this varies per location and time, availability of testing, changes in policy, and so forth. The data also might contain reporting errors, notice how there are negative numbers in what otherwise should be cumulative confirmed cases for France in the penultimate time series.

---


## Contents {#contents-link}

* [Data Pre-Processing](#preprocess-link): brief description of data pre-processing and cleanup steps.
* [Data Wrangling and Enrichment](#enrich-link): adding population data and calculated columns.
* [Exploratory Data Analysis](#eda-link): main section with visualizations.
* [Code Appendix](#codeappendix-link): entire R code.

---

## Data Pre-Processing {#preprocess-link}

I focused on confirmed cases and fatal cases. See [Code Appendix](#codeappendix-link) for full, commented code.


```{r include=FALSE}
# environment setup 
rm(list = ls())
options(scipen=999)

# setwd("../GitHub/CoronavirusDataAnalysis") # base R

# install and load packages  
install_packages <- function(package){
    newpackage <- package[!(package %in% installed.packages()[, "Package"])]
  	if (length(newpackage)) {
        suppressMessages(install.packages(newpackage, dependencies = TRUE)) 
  	} 
  	sapply(package, require, character.only = TRUE)
}

packages <- c("dygraphs", "tidyverse", "xts", "RColorBrewer", "kableExtra", "sqldf")
suppressPackageStartupMessages(install_packages(packages))

# create data dir if not exists
if (!file.exists("data")) dir.create("data")

# check if today's pre-processed data exists
rds_file <- paste0("./data/", gsub("-", "", Sys.Date()), "_data.rds")

# if not, download it
if (!file.exists(rds_file)) {
  
    # download datasets
    base_url <- paste0("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/"
                      , "csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_")
    
    setwd("data")
    system(paste0("curl -LJO ", base_url, "confirmed_global.csv"))
    system(paste0("curl -LJO ", base_url, "deaths_global.csv"))
    setwd("..")
  
    # load downloaded datasets
    confirmed  <- read.csv("data/time_series_covid19_confirmed_global.csv")
    deaths <- read.csv("data/time_series_covid19_deaths_global.csv")
    
    # reshape datasets
    reshape_data <- function(dfm) {
      
        # drop cols & rename Country.Province
        dfm <- dfm[ ,!colnames(dfm) %in% c("Province.State", "Lat", "Long")]
        names(dfm)[1] <- "Country"
        
        # wide to long
        dfm <- dfm %>% pivot_longer(
            cols = starts_with("X")
            , names_to = "Date"
            , values_to = "Count"
        )
        
        # cleanup date col
        dfm$Date <- as.Date(sub("X", "", dfm$Date) , format="%m.%d.%y")
        as.data.frame(dfm)
    }
    
    confirmed <- reshape_data(confirmed)
    deaths <- reshape_data(deaths)
    
    # add status column
    confirmed$Status <- "Confirmed"
    deaths$Status <- "Fatal"
    
    # combine
    dfm <- rbind(confirmed, deaths, make.row.names = FALSE)
    
    # change Status to factor
    dfm$Status <- as.factor(dfm$Status)
    
    deduplicate_provinces <- function(dfm) {
      
        # fix level of aggregation to Country only
        dfm <- dfm %>% 
            select(Country, Status, Date, Count) %>%
    			  group_by(Country, Status, Date) %>%
    		  	summarise(Count = sum(Count)) %>%
    		  	arrange(Country, Status, desc(Date)
    		)
        
    		as.data.frame(dfm)
    }
    
    dfm <- deduplicate_provinces(dfm)
    
    saveRDS(dfm, file = rds_file)

}

# cleanup env and read in RDS file
rm(list=ls()[-which(ls() == "rds_file")])
dfm <- readRDS(rds_file)
```


```{r echo=FALSE}
# calculate number of countries and number of days in the time series
Ncountries <- length(unique(dfm$Country))
Ndays <- length(unique(dfm$Date))
```


The pre-processed dataset is comprised of `r nrow(dfm)` rows and `r length(dfm)` columns. Each single-status dataset is as long as the number of days times the number of countries for the data in a given day. Today there are `r Ndays` days and `r Ncountries` countries in the data, after removing the small and seasonal populations of Antarctica and the Olympics.

The project focuses on countries so latitude, longitude, and the sub-national province/state columns were discarded. These are the top and bottom rows of the pre-processed dataset:

```{r echo=FALSE}
# top and bottom rows for final dataset
kable(rbind(head(dfm, 3), tail(dfm, 3))) %>%
      kable_styling(bootstrap_options = c("striped", "hover", "condensed")
                    , full_width = FALSE)
```

---

[Back to [Contents](#contents-link)]{style="float:right"}


## Data Wrangling and Enrichment {#enrich-link}


I maintain a static data set of countries and their populations. This data is cobbled together with internet searches and [World Health Organization data.](https://apps.who.int/gho/data/view.main.POP2040ALL?lang=en) I use the country's population to calculate a `Percentage` column with the percentage of cases given a country and a status. I also calculate the difference between each day and the previous day's counts as the `NewCases` variable.

```{r include=FALSE}
# remove seasonal "countries" like Antarctica and Olympics
dfm <- dfm[!dfm$Country %in% c('Antarctica', 'Summer Olympics 2020', 'Winter Olympics 2022'), ]

# read in static data set of countries and populations
country_population <- read.csv("data/country_population.csv")
		  
# test for new countries in data -- manual step
current_countries <- unique(dfm$Country)
current_countries[!current_countries %in% country_population$Country]
```



```{r include=FALSE}
# merge data sets
merged <- merge(dfm, country_population, by = "Country")

# calculate percentages
merged$Percentage <- round(merged$Count/(merged$Population*1000)*100, 3)

# reorder by Country, Status, and Date descending
merged <- data.frame(merged %>% arrange(Country, Status, desc(Date)))

# calculate new cases
merged <- sqldf('
	SELECT 
		sq.*
		, LEAD(sq.CountLag - Count, 1) OVER (PARTITION BY Country, Status) AS NewCases
	FROM (
		SELECT 
			p.*
			, LAG(Count, 1) OVER (PARTITION BY Country, Status) AS CountLag
		FROM merged AS p
		) AS sq
')

# remove temp col, replace NA, convert to int
merged$CountLag <- NULL
merged$NewCases[is.na(merged$NewCases)] <- 0
merged$NewCases <- as.integer(merged$NewCases)
```


The top rows of the enriched data set for Brazil and the US are:

```{r echo=FALSE}
# top and bottom rows for final data set
kable(rbind(head(merged[merged$Country == "Brazil", ], 3)
            , head(merged[merged$Country == "US", ], 3))) %>%
      kable_styling(bootstrap_options = c("striped", "hover", "condensed")
                  , full_width = FALSE)
```

---

[Back to [Contents](#contents-link)]{style="float:right"}


## Exploratory Data Analysis {#eda-link}


### Total Counts

```{r echo=FALSE, fig.height=6, fig.width=6} 
# subset to current counts 
current_data <- data.frame(
    merged %>%
    filter(Date == unique(merged$Date)[1])) %>%
    arrange(Status, desc(Count)
)

# subset to world totals 
world_totals <- data.frame(current_data %>% 
					group_by(Status) %>%
					summarise('Total'=sum(Count)))

world_totals$Total <- formatC(world_totals$Total, big.mark=",")

kable(world_totals) %>%
      kable_styling(bootstrap_options = c("striped", "hover")
                    , full_width = FALSE)
```



---

### Bar Charts

See this [Shiny app](https://bigbangdata.shinyapps.io/shinyapp/) for interactive bar charts with the latest counts and percentages.


```{r echo=FALSE}
# subset to country totals 
country_totals <- data.frame(
    current_data %>%
		select(Country, Status, Count, Percentage, NewCases) %>%
		group_by(Country, Status)
)
	
# subset to top counts 	
get_top_counts <- function(dfm, coln, num) {
	  dfm <- dfm[dfm$Status == coln, ][1:num, ]
	  row.names(dfm) <- 1:num
	  dfm
}					

# separate by status 
top_confirmed 	<- get_top_counts(country_totals, "Confirmed", 10)
top_fatal		<- get_top_counts(country_totals, "Fatal", 10)
```


---

### Interactive Time Series Plots

Counts and percentages of the top five countries for confirmed and fatal cases.


```{r message=FALSE, warnings=FALSE, echo=FALSE}
# functions for plotting interactive time series
# arg values:
# dfm = the dataframe
# country = country name
# status_df = to be used as the vector of country names 
#             which is passed instead of a single country
# status = Confirmed, Fatal, Recovered, Active
# scale_ = Linear, Log
# type = Count, Percentage, NewCases
create_xts_series <- function(dfm, country, status, scale_, type) {
  
  	dfm <- dfm[dfm$Country == country & dfm$Status == status, ]
  	
  	if (type == "Count") {
  	  series <- if (scale_ == "Linear") {
  	  			  xts(dfm$Count, order.by = dfm$Date)
  	  		} else {
  	  		    xts(log(dfm$Count), order.by = dfm$Date)
  	  		}
  	} else if (type == "Percentage") {
  	  series <- if (scale_ == "Linear") {
  	  			  xts(dfm$Percentage, order.by = dfm$Date)
  	  		} else {
  	  		    xts(log(dfm$Percentage), order.by = dfm$Date)
  	  		}
  	} else { # for new cases
  	  series <- if (scale_ == "Linear") {
  	  			  xts(dfm$NewCases, order.by = dfm$Date)
  	  		} else {
  	  		    xts(log(dfm$NewCases), order.by = dfm$Date)
  	  		}
  	}
  	series
}

create_seriesObject <- function(dfm, status_df, status, scale_, type) {
  
    seriesObject <- NULL
    
    for (i in 1:5) {
        seriesObject <- cbind(seriesObject
                              , create_xts_series(dfm
                                                  , status_df$Country[i]
                                                  , status
                                                  , scale_
                                                  , type))
    }
    
    names(seriesObject) <- status_df$Country[1:5]
    seriesObject
}

plot_interactive_df <- function(dfm, status_df, status, scale_, type) {
  
    seriesObject <- create_seriesObject(dfm
                  									  , status_df
                  									  , status
                  									  , scale_
                  									  , type)
    
    if (type == "Count") {
  
        txt_ <- if (scale_ == "Linear") {
    	  				"Count Of "
    	  			} else {
    	  			  "Log Count Of "
    	  			}			
  				
    } else if (type == "Percentage") {
        
        txt_ <- if (scale_ == "Linear") {
    	  				"Percentage Of "
    	  			} else {
    	  			  "Log Percentage Of "
    	  			} 		
  				
    } else { # for new cases
      
        txt_ <- if (scale_ == "Linear") {
    	  				"New "
    	  			} else {
    	  			  "Log Of New "
    	  			}  	
    }
    
    ylab_lab   <- paste0(txt_, status, " Cases")
    main_title <- paste0("Top Countries - ", txt_, status, " Cases")
    
    interactive_df <- dygraph(seriesObject, main = main_title) %>% 
  					dyAxis("x", drawGrid = FALSE) %>%							
  					dyAxis("y", label = ylab_lab) %>%
  					dyOptions(colors=brewer.pal(5, "Dark2")
  							, axisLineWidth = 1.5
  							, axisLineColor = "navy"
  							, gridLineColor = "lightblue") %>%			
  					dyRangeSelector() %>%
  					dyLegend(width = 750)
    
    interactive_df
}
```


```{r message=FALSE, warnings=FALSE, echo=FALSE}
## plot time series
plot_types <- data.frame(
    'Num' = 1:12
    , 'Status' = c(rep("Confirmed", 6), rep("Fatal", 6))
    , 'Type' = rep(c("Count", "Percentage", "NewCases"), each=2)
    , 'Scale' = rep(c("Linear", "Log"), 6)
)

# fatal
fatal_plots <- lapply(1:3, function(i) plot_interactive_df(merged
  							                     , top_fatal[1:5, ]
  							                     , top_fatal$Status[i]
  							                     , plot_types$Scale[i]
  							                     , plot_types$Type[i]))
		
htmltools::tagList(fatal_plots)

# confirmed 
confirmed_plots <- lapply(1:3, function(i) plot_interactive_df(merged
      							                     , top_confirmed[1:5, ]
      							                     , top_confirmed$Status[i]
      							                     , plot_types$Scale[i]
      							                     , plot_types$Type[i]))
		
htmltools::tagList(confirmed_plots)
```



### Further Plots to Consider


Future iterations could include other interesting metrics such as:

- Doubling rates
- Proportion of New Cases to Total Cases
- Percentage increase plus a horizontal line showing proportion of population to world population


---


[Back to [Contents](#contents-link)]{style="float:right"}

### Code Appendix {#codeappendix-link}

Fork or clone this [GitHub repository](https://github.com/BigBangData/CoronavirusDataAnalysis) with all files and code, including the code for the Shiny app.

```{r eval=FALSE}
## ----setup, include=FALSE---------------------------------------------------------------------------------------------------------------
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)


## ----include=FALSE----------------------------------------------------------------------------------------------------------------------
# environment setup 
rm(list = ls())
options(scipen=999)

# setwd("../GitHub/CoronavirusDataAnalysis") # base R

# install and load packages  
install_packages <- function(package){
    newpackage <- package[!(package %in% installed.packages()[, "Package"])]
  	if (length(newpackage)) {
        suppressMessages(install.packages(newpackage, dependencies = TRUE)) 
  	} 
  	sapply(package, require, character.only = TRUE)
}

packages <- c("dygraphs", "tidyverse", "xts", "RColorBrewer", "kableExtra", "sqldf")
suppressPackageStartupMessages(install_packages(packages))

# create data dir if not exists
if (!file.exists("data")) dir.create("data")

# check if today's pre-processed data exists
rds_file <- paste0("./data/", gsub("-", "", Sys.Date()), "_data.rds")

# if not, download it
if (!file.exists(rds_file)) {
  
    # download datasets
    base_url <- paste0("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/"
                      , "csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_")
    
    setwd("data")
    system(paste0("curl -LJO ", base_url, "confirmed_global.csv"))
    system(paste0("curl -LJO ", base_url, "deaths_global.csv"))
    setwd("..")
  
    # load downloaded datasets
    confirmed  <- read.csv("data/time_series_covid19_confirmed_global.csv")
    deaths <- read.csv("data/time_series_covid19_deaths_global.csv")
    
    # reshape datasets
    reshape_data <- function(dfm) {
      
        # drop cols & rename Country.Province
        dfm <- dfm[ ,!colnames(dfm) %in% c("Province.State", "Lat", "Long")]
        names(dfm)[1] <- "Country"
        
        # wide to long
        dfm <- dfm %>% pivot_longer(
            cols = starts_with("X")
            , names_to = "Date"
            , values_to = "Count"
        )
        
        # cleanup date col
        dfm$Date <- as.Date(sub("X", "", dfm$Date) , format="%m.%d.%y")
        as.data.frame(dfm)
    }
    
    confirmed <- reshape_data(confirmed)
    deaths <- reshape_data(deaths)
    
    # add status column
    confirmed$Status <- "Confirmed"
    deaths$Status <- "Fatal"
    
    # combine
    dfm <- rbind(confirmed, deaths, make.row.names = FALSE)
    
    # change Status to factor
    dfm$Status <- as.factor(dfm$Status)
    
    deduplicate_provinces <- function(dfm) {
      
        # fix level of aggregation to Country only
        dfm <- dfm %>% 
            select(Country, Status, Date, Count) %>%
    			  group_by(Country, Status, Date) %>%
    		  	summarise(Count = sum(Count)) %>%
    		  	arrange(Country, Status, desc(Date)
    		)
        
    		as.data.frame(dfm)
    }
    
    dfm <- deduplicate_provinces(dfm)
    
    saveRDS(dfm, file = rds_file)

}

# cleanup env and read in RDS file
rm(list=ls()[-which(ls() == "rds_file")])
dfm <- readRDS(rds_file)


## ----echo=FALSE-------------------------------------------------------------------------------------------------------------------------
# calculate number of countries and number of days in the time series
Ncountries <- length(unique(dfm$Country))
Ndays <- length(unique(dfm$Date))


nrow(dfm)
length(dfm)
Ndays
Ncountries
## ----echo=FALSE-------------------------------------------------------------------------------------------------------------------------
# top and bottom rows for final dataset
kable(rbind(head(dfm, 3), tail(dfm, 3))) %>%
      kable_styling(bootstrap_options = c("striped", "hover", "condensed")
                    , full_width = FALSE)


## ----include=FALSE----------------------------------------------------------------------------------------------------------------------
# remove seasonal "countries" like Antarctica and Olympics
dfm <- dfm[!dfm$Country %in% c('Antarctica', 'Summer Olympics 2020', 'Winter Olympics 2022'), ]

# read in static data set of countries and populations
country_population <- read.csv("data/country_population.csv")
		  
# test for new countries in data -- manual step
current_countries <- unique(dfm$Country)
current_countries[!current_countries %in% country_population$Country]


## ----include=FALSE----------------------------------------------------------------------------------------------------------------------
# merge data sets
merged <- merge(dfm, country_population, by = "Country")

# calculate percentages
merged$Percentage <- round(merged$Count/(merged$Population*1000)*100, 3)

# reorder by Country, Status, and Date descending
merged <- data.frame(merged %>% arrange(Country, Status, desc(Date)))

# calculate new cases
merged <- sqldf('
	SELECT 
		sq.*
		, LEAD(sq.CountLag - Count, 1) OVER (PARTITION BY Country, Status) AS NewCases
	FROM (
		SELECT 
			p.*
			, LAG(Count, 1) OVER (PARTITION BY Country, Status) AS CountLag
		FROM merged AS p
		) AS sq
')

# remove temp col, replace NA, convert to int
merged$CountLag <- NULL
merged$NewCases[is.na(merged$NewCases)] <- 0
merged$NewCases <- as.integer(merged$NewCases)


## ----echo=FALSE-------------------------------------------------------------------------------------------------------------------------
# top and bottom rows for final data set
kable(rbind(head(merged[merged$Country == "Brazil", ], 3)
            , head(merged[merged$Country == "US", ], 3))) %>%
      kable_styling(bootstrap_options = c("striped", "hover", "condensed")
                  , full_width = FALSE)


## ----echo=FALSE, fig.height=6, fig.width=6----------------------------------------------------------------------------------------------
# subset to current counts 
current_data <- data.frame(
    merged %>%
    filter(Date == unique(merged$Date)[1])) %>%
    arrange(Status, desc(Count)
)

# subset to world totals 
world_totals <- data.frame(current_data %>% 
					group_by(Status) %>%
					summarise('Total'=sum(Count)))

world_totals$Total <- formatC(world_totals$Total, big.mark=",")

kable(world_totals) %>%
      kable_styling(bootstrap_options = c("striped", "hover")
                    , full_width = FALSE)


## ----echo=FALSE-------------------------------------------------------------------------------------------------------------------------
# subset to country totals 
country_totals <- data.frame(
    current_data %>%
		select(Country, Status, Count, Percentage, NewCases) %>%
		group_by(Country, Status)
)
	
# subset to top counts 	
get_top_counts <- function(dfm, coln, num) {
	  dfm <- dfm[dfm$Status == coln, ][1:num, ]
	  row.names(dfm) <- 1:num
	  dfm
}					

# separate by status 
top_confirmed 	<- get_top_counts(country_totals, "Confirmed", 10)
top_fatal		<- get_top_counts(country_totals, "Fatal", 10)


## ----message=FALSE, warnings=FALSE, echo=FALSE------------------------------------------------------------------------------------------
# functions for plotting interactive time series
# arg values:
# dfm = the dataframe
# country = country name
# status_df = to be used as the vector of country names 
#             which is passed instead of a single country
# status = Confirmed, Fatal, Recovered, Active
# scale_ = Linear, Log
# type = Count, Percentage, NewCases
create_xts_series <- function(dfm, country, status, scale_, type) {
  
  	dfm <- dfm[dfm$Country == country & dfm$Status == status, ]
  	
  	if (type == "Count") {
  	  series <- if (scale_ == "Linear") {
  	  			  xts(dfm$Count, order.by = dfm$Date)
  	  		} else {
  	  		    xts(log(dfm$Count), order.by = dfm$Date)
  	  		}
  	} else if (type == "Percentage") {
  	  series <- if (scale_ == "Linear") {
  	  			  xts(dfm$Percentage, order.by = dfm$Date)
  	  		} else {
  	  		    xts(log(dfm$Percentage), order.by = dfm$Date)
  	  		}
  	} else { # for new cases
  	  series <- if (scale_ == "Linear") {
  	  			  xts(dfm$NewCases, order.by = dfm$Date)
  	  		} else {
  	  		    xts(log(dfm$NewCases), order.by = dfm$Date)
  	  		}
  	}
  	series
}

create_seriesObject <- function(dfm, status_df, status, scale_, type) {
  
    seriesObject <- NULL
    
    for (i in 1:5) {
        seriesObject <- cbind(seriesObject
                              , create_xts_series(dfm
                                                  , status_df$Country[i]
                                                  , status
                                                  , scale_
                                                  , type))
    }
    
    names(seriesObject) <- status_df$Country[1:5]
    seriesObject
}

plot_interactive_df <- function(dfm, status_df, status, scale_, type) {
  
    seriesObject <- create_seriesObject(dfm
                  									  , status_df
                  									  , status
                  									  , scale_
                  									  , type)
    
    if (type == "Count") {
  
        txt_ <- if (scale_ == "Linear") {
    	  				"Count Of "
    	  			} else {
    	  			  "Log Count Of "
    	  			}			
  				
    } else if (type == "Percentage") {
        
        txt_ <- if (scale_ == "Linear") {
    	  				"Percentage Of "
    	  			} else {
    	  			  "Log Percentage Of "
    	  			} 		
  				
    } else { # for new cases
      
        txt_ <- if (scale_ == "Linear") {
    	  				"New "
    	  			} else {
    	  			  "Log Of New "
    	  			}  	
    }
    
    ylab_lab   <- paste0(txt_, status, " Cases")
    main_title <- paste0("Top Countries - ", txt_, status, " Cases")
    
    interactive_df <- dygraph(seriesObject, main = main_title) %>% 
  					dyAxis("x", drawGrid = FALSE) %>%							
  					dyAxis("y", label = ylab_lab) %>%
  					dyOptions(colors=brewer.pal(5, "Dark2")
  							, axisLineWidth = 1.5
  							, axisLineColor = "navy"
  							, gridLineColor = "lightblue") %>%			
  					dyRangeSelector() %>%
  					dyLegend(width = 750)
    
    interactive_df
}


## ----message=FALSE, warnings=FALSE, echo=FALSE------------------------------------------------------------------------------------------
## plot time series
plot_types <- data.frame(
    'Num' = 1:12
    , 'Status' = c(rep("Confirmed", 6), rep("Fatal", 6))
    , 'Type' = rep(c("Count", "Percentage", "NewCases"), each=2)
    , 'Scale' = rep(c("Linear", "Log"), 6)
)

# fatal
fatal_plots <- lapply(1:3, function(i) plot_interactive_df(merged
  							                     , top_fatal[1:5, ]
  							                     , top_fatal$Status[i]
  							                     , plot_types$Scale[i]
  							                     , plot_types$Type[i]))
		
htmltools::tagList(fatal_plots)

# confirmed 
confirmed_plots <- lapply(1:3, function(i) plot_interactive_df(merged
      							                     , top_confirmed[1:5, ]
      							                     , top_confirmed$Status[i]
      							                     , plot_types$Scale[i]
      							                     , plot_types$Type[i]))
		
htmltools::tagList(confirmed_plots)
```




```{r}
# uncomment to run, creates Rcode file with R code, set documentation = 1 to avoid text commentary
#library(knitr)
#options(knitr.purl.inline = TRUE)
#purl("CoronavirusDataAnalysis.Rmd", output = "Rcode.R", documentation = 1)
``` 